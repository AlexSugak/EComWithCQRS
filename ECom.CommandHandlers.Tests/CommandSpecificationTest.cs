using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ECom.Messages;
using ECom.Infrastructure;
using System.Reflection;

namespace ECom.CommandHandlers.Tests
{
    [TestClass]
    public abstract class CommandSpecificationTest<TCommand> where TCommand : ICommand
    {
        //protected IProjectionStore projectionStore;
        //protected TestExecutionContext executionContext;

        protected Bus.Bus Bus;
        protected FakeEventStore FakeEventStore;


        [TestInitialize]
        public virtual void SetUp()
        {
            //this.projectionStore = new InMemoryProjectionStore();
            //this.executionContext = new TestExecutionContext();

            var commandHandlersAssembly = Assembly.Load(new AssemblyName("ECom.Domain"));
            FakeEventStore = new FakeEventStore();
            Bus = new Bus.Bus();
            MessageHandlersRegister.RegisterCommandHandlers(new[] { commandHandlersAssembly }, Bus, FakeEventStore);
        }

        protected void Assert(ICommandSpec<TCommand> specification)
        {
            Exception Cought = null;
            FakeEventStore.SetupEventsHistory(specification.Given);

            // Replay events to service bus for the fake projections to rebuild
            //foreach (var e in specification.Given)
            //    this.context.Handle(e);

            //this.serviceBus.Reset();

            try
            {
                //this.context.Execute(specification.When);
                Bus.Send(specification.When);
            }
            catch (Exception e)
            {
                Cought = e;
            }

            // if exception is expected
            if (specification is FailingCommandSpecification<TCommand>)
            {
                var expected = (specification as FailingCommandSpecification<TCommand>).ExpectException;
                if (Cought == null)
                {
                    Microsoft.VisualStudio.TestTools.UnitTesting.Assert.Fail("Expected exception was not cought");
                    return;
                }
                if (Cought.GetType() != expected.GetType())
                {
                    Microsoft.VisualStudio.TestTools.UnitTesting.Assert.Fail("Cought exception is not the one that was expected: \n{0}\n\n{1}", expected, Cought);
                    return;
                }

                return;
            }

            // If there's unexpected exception
            if (Cought != null)
            {
                Microsoft.VisualStudio.TestTools.UnitTesting.Assert.Fail("Unexpected exception was thrown: {0}", Cought.ToString());
                return;
            }

            var spec = specification as CommandSpecification<TCommand>;
            // if regular command spec
            if (spec != null)
            {
                var producedEvents = FakeEventStore.NewEvents().ToList();
                var expectedEvents = spec.ExpectEvents.ToList();

                //TODO: Need to check not only events but olso commands generated by BL
                Microsoft.VisualStudio.TestTools.UnitTesting.Assert.IsTrue(AssertEvents.AreSame(producedEvents, spec.ExpectEvents), "The lists of expected and provided commands and events do not match");
                return;
            }
            Microsoft.VisualStudio.TestTools.UnitTesting.Assert.Fail("Unknown specification type");
        }
    }

    public static class AssertEvents
    {
        public static bool AreSame<T>(IEnumerable<T> actual, IEnumerable<T> expected)
        {
            var actualEnumerator = actual.GetEnumerator();
            var expectedEnumerator = expected.GetEnumerator();

            while (true)
            {
                var actualOver = actualEnumerator.MoveNext();
                var expectedOver = expectedEnumerator.MoveNext();
                if (actualOver != expectedOver)
                    return false;
                if (actualOver == false)
                    return true;
                if (!actualEnumerator.Current.Equals(expectedEnumerator.Current))
                    return false;
            }
        }
    }

    public interface ICommandSpec<T>
        where T : ICommand
    {
        List<IEvent> Given { get; }
        T When { get; }
    }

    public class CommandSpecification<T> : ICommandSpec<T>
        where T : ICommand
    {
        public List<IEvent> Given { get; set; }
        public T When { get; set; }
        public List<IEvent> ExpectEvents { get; set; }
        public List<ICommand> ExpectCommands { get; set; }

        public CommandSpecification()
        {
            this.Given = new List<IEvent>();
            this.ExpectEvents = new List<IEvent>();
            this.ExpectCommands = new List<ICommand>();
        }
    }

    public class FailingCommandSpecification<T> : ICommandSpec<T>
        where T : ICommand
    {
        public List<IEvent> Given { get; set; }
        public T When { get; set; }
        public Exception ExpectException { get; set; }

        public FailingCommandSpecification()
        {
            this.Given = new List<IEvent>();
        }
    }
}
