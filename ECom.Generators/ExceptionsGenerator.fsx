// 
// This is the script generating Events classes
// 
//  In order to add, modify, delete event do the following:
//  1. Scroll to the end of the file, there're definitions of the events
//  2. add, modify, delete the event definition
//      Note: events should be in the following format:
//          event "<eventName>" [<agrument separated by semicolon(;)>]
//      where each argument is either:
//          <typeAlias> "<argumentName>"
//      or
//          arg "<argumentName>" typeof<argumentType>
//
//      Example:
//          event "UserRegistered" [string "Email"; string "Password"; int "Age"]
//      the same command
//          event "UserRegistered" [arg "Email" typeof<string>; arg "Password" typeof<string>; arg "Age" typeof<int>]
//
//      When the modification of definitions is done, you need to generate classes. For that
//      1. Select all text in this file (Ctrl+A)
//      2. Press Alt+Enter
//      3. In Visual studio new windows will be opened "F# Interactive". There will be the result of scrit execution. In the context menu of that windows call "Reset interaction session" menu item to release the dll
//

#if INTERACTIVE
#r "bin\Debug\ECom.Messages.dll"
#endif

open System
open System.IO
open ECom.Messages

//===================================================

let stamp = String.Format("//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the \"{0}\" script.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
", __SOURCE_FILE__)

type argument =
    {
        Name: string
        Type: Type
    }   

let toCamel (value:string) = String.Format("{0}{1}", value.[0].ToString().ToLower(), value.Substring(1))

let arg (argName:string) (argType:Type) = {argument.Name = argName; Type = argType}

let fieldTempate = "
    [DataMember(Name = \"{0}\")]
    private {1} {2};

    public {1} {0}
    {{
        get {{ return this.{2}; }}
    }}
"
let ctorParams = "{1} {0}"
let ctorAssignment = "
        this.{0} = {0};"

let exceptionRecordTemplate = "
[GeneratedCodeAttribute(\"ExceptionsGenerator.fsx\", \"1.0.0.0\")]
[DataContract]
public sealed class {0}: Exception, IEquatable<{0}>
{{
    private const string defaultMessage = \"{4}\";
    {1}
    public {0}()
    {{
    }}

    public {0}(string message): base(message)
    {{
    }}

    public {0}(string message, Exception innerException): base(message, innerException)
    {{
    }}

    public {0}({2}): base(defaultMessage)
    {{{3}
    }}

    public {0}({2}, Exception innerException): base(defaultMessage, innerException)
    {{{3}
    }}

    public {0}({2}, string message, Exception innerException): base(message, innerException)
    {{{3}
    }}

    public bool Equals({0} other)
    {{
        if (this != null)
		{{
			return other != null && {5};
		}}
		return other == null;
    }}

    public override bool Equals(object obj)
    {{
        var other = obj as {0};
        return other != null && this.Equals(other);
    }}

    public override int GetHashCode()
    {{
        return {6};
    }}
}}
"
let exceptionShortRecordTemplate = "
[DataContract]
public sealed class {0}: Exception, IEquatable<{0}>
{{
    private const string defaultMessage = \"{4}\";
    {1}
    public {0}()
    {{
    }}

    public {0}({2}): base(defaultMessage)
    {{{3}
    }}

    public {0}({2}, Exception innerException): base(defaultMessage, innerException)
    {{{3}
    }}

    public {0}({2}, string message, Exception innerException): base(message, innerException)
    {{{3}
    }}

    public bool Equals({0} other)
    {{
        if (this != null)
		{{
			return other != null && {5};
		}}
		return other == null;
    }}

    public override bool Equals(object obj)
    {{
        var other = obj as {0};
        return other != null && this.Equals(other);
    }}

    public override int GetHashCode()
    {{
        return {6};
    }}
}}
"

let equalityExpression args = args |> List.choose (fun x -> Some(String.Format("{0}.Equals(this.{1}, other.{1})", x.Type.Name, x.Name))) |> List.reduce (fun x y -> x + " && " + y)
let hashGenerator args = args |> List.choose (fun x -> Some(if (x.Type.IsValueType) then String.Format("this.{0}.GetHashCode()", x.Name) else String.Format("((this.{0} == null) ? 0 : this.{0}.GetHashCode())", x.Name))) |> List.reduce (fun x y -> x + " ^ " + y)

let record (recordTemplate:string) (name:string) args (defaultMessage:string) =
    String.Format(recordTemplate, name, args |> List.choose (fun x -> Some(String.Format(fieldTempate, x.Name, x.Type.Name, toCamel x.Name))) |> List.reduce (fun x y -> x + y), args |> List.choose (fun x -> Some(String.Format(ctorParams, toCamel x.Name, x.Type.Name))) |> List.reduce (fun x y -> String.Format("{0}, {1}", x, y)), args |> List.choose (fun x -> Some(String.Format(ctorAssignment, toCamel x.Name))) |> List.reduce (fun x y -> x + y), defaultMessage, equalityExpression args, hashGenerator args)

let Generate elements = File.WriteAllText (Path.Combine(__SOURCE_DIRECTORY__, "..\ECom.Messages\Exceptions.cs"), List.reduce (fun x y -> x + y) (stamp::elements))

let exc name args defaultMessage = record exceptionRecordTemplate name (args) defaultMessage
let excShort name args defaultMessage = record exceptionShortRecordTemplate name (args) defaultMessage


//===================================================

let header = "
using System;
using System.CodeDom.Compiler;
using System.Runtime.Serialization;

namespace ECom.Messages
{
"

let footer = "
}
"

// Type aliases
let guid name = arg name typeof<Guid>
let string name = arg name typeof<string>
let int name = arg name typeof<int>
let byte name = arg name typeof<byte>
let bool name = arg name typeof<bool>
let datetime name = arg name typeof<DateTime>
let date name = arg name typeof<DateTime>
let decimal name = arg name typeof<decimal>
let id name = arg name typeof<IIdentity>


// Events
let events = [
                header

                exc "AggregateRootNotFoundException"    [arg "AggregateType" typeof<Type>; arg "AggregateId" typeof<Object>] "Requested aggregate root was not found"
                exc "DuplicateEntityException"          [arg "EntityType" typeof<Type>; arg "EntityId" typeof<Object>] "Specified entity already exists"
                exc "EntityNotFoundException"           [arg "EntityType" typeof<Type>; arg "AggregateId" typeof<Object>; arg "EntityId" typeof<Object>] "Requested entity was not found"
                exc "ReferencedEntityNotFoundException" [string "EntityType"; id "EntityId"] "Referenced entity was not found"

                footer
            ]

Generate (events)
